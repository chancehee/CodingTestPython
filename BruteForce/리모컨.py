"""
브루트포스: <리모컨>

1.아이디어:
    가고자 하는 채널에 고장난 버튼이 있다면 +1 or -1을 해주어 가장 가까운 채널을
    만든 후 계산하려고 하였으나, 채널 구현과 시간 적인 측면에서 어려움을 느끼고
    블로그 글을 참고하였다.

    해결책은 범위내에 고장 나지 않은 채널들을 범위내에서 모두 탐색하는 것이 였다.
    따라서 1. ++, --로만 원하는 채널로 이동하는 경우: abs(현재 채널 - 원하는 채널)
    vs
    2. abs(고장 나지 않은 모든 채널 각각- 원하는 채널) + len(고장 나지 않은 모든 채널 각각)

    1번과 2번을 비교하여 min 값을 계속 갱신해주고 최종 min값을 리턴해준다.

    ( 이동하려고 하는 채널이 0 <= N <= 500,000 인데, 만약 고장난 버튼이 9이고 원하는 채널이 500,000이라면
    len(488,888) + abs(488,888 - 500,000) vs len(500,001) + abs(500,001 - 500,000)
    위의 경우에서 후자가 버튼을 더 적게 누른다.
    따라서 탐색하는 채널의 범위는 이동하려고 하는 채널 범위의 2배로 설정해준다.
"""

target = int(input()) # 원하는 채널
ans = abs(100 - target) # 1. ++ or -- 로 이동할 경우 -> 최댓값
M = int(input())

if M: # 고장난 버튼이 있는 경우
    broken = list(input().split())
else:
    broken = []

# 2. 고장난 버튼이 없는 모든 채널을 탐색
for num in range(1000001):
    for n in str(num):
        if n in broken:
            break
    else: # 채널을 눌렀을 때 고장난 버튼이 없는 경우
        ans = min(ans, len(str(num)) + abs(num - target))

print(ans)